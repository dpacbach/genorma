#!/bin/bash
# ===============================================================
# This is a make file generator for the nr-make system.
# ===============================================================
echo "nr-make: project generator"

# ===============================================================
# Utility functions
# ===============================================================
error() {
    echo -e >&2 "$@"
    exit 1
}

log() { echo -e "[LOG] $@"; }

msg() { echo -n -e "$@"; }

log_var() {
    eval "local __v=\${$1}"
    spaces=" "
    if [[ "$__v" =~ $spaces ]]; then
        log "$1=\"$__v\""
    else
        log "$1=$__v"
    fi
}

# This is a readlink that  will  return the resolved and absolute
# path of a file or pointed to by a link  in  a  way  that  works
# across Unix variants.
readlink_abs_compat() {
    file="$1"
    # We could have links pointing to  links, so need to keep re-
    # solving until that's not the case.
    while test -L "$file"; do
        file="$(readlink "$file")"
    done
    # Get folder/basename
    echo "$(cd "$(dirname "$file")" && pwd)/$(basename "$file")"
}

# ===============================================================
# Create the  top-level  symlink  from  Makefile  -->  nr-make.mk
# ===============================================================
makefile_link() {
    this="$1"; shift
    root="$1"; shift
    [[ ! -e "$root" ]] && {
        mkdir -p "$root" || error "failed to create $root" 
    }
    [[ -d "$root" ]] || error "root $root not a directory"
    [[ -e "$root"/Makefile ]] &&
        error "$root/Makefile already exists"
    # Should finally be safe to create the link
    ln -s "$this/nr-make.mk" "$root/Makefile" ||
        error "failed to create symlink"
    return 0
}

# ===============================================================
# The empty program that will be created
# ===============================================================
stub_main='// Generated by nr-make

#include <iostream>

using namespace std;

int main()
{
    cout << "Hello, World!" << endl;
    return 0;
}'

# ===============================================================
# Creates a new project
# ===============================================================
init() {
    kind="$1"; shift
    root="$1"; shift
    case "$kind" in
        simple)
            [[ -z "$root" ]] && root="."
            # It  is  safe  to do this now because we should have
            # already checked to make sure we're not being
            # sourced.
            this="$(dirname "$(readlink_abs_compat "$0")")" ||
                error "failed to get abs path of script"
            makefile_link "$this" "$root" || return 2
            # If  there  are  not  c/cpp source files in the root
            # folder then create a stub.
            count="$(ls $root/*.c $root/*.cpp 2>/dev/null | wc -l)"
            if (( count == 0 )); then
                msg "Creating stub main.cpp\n"
                echo "$stub_main" >> "$root/main.cpp" ||
                    error "failed to write stub $stub_main"
            fi
            return $?
        ;;
        standard)
            error "standard mode not yet supported."
        ;;
        *)
            msg "Usage: nr-make init kind\n"
            msg "\n"
            msg "   kind can be: simple\n"
            msg "                standard\n"
            return 1
        ;;
    esac
    # !! Should not get here
    return 1
}

usage='
Usage: nr-make mode [...]

    mode can be: init

Example 1. to create a new simple project
           in the current directory:

    $ nr-make init simple

Example 2. to create a new simple project
           in a given folder (which will be
           created if it does not exist):

    $ nr-make init simple path/to/folder
'

# ===============================================================
# Driver
# ===============================================================
main() {
    mode="$1"; shift

    case "$mode" in
        init)
            init "$@"
            return $?
        ;;
        *)
            echo "$usage"
            return 1
        ;;
    esac
    # !! Should not get here
    return 1
}

# ===============================================================
# Detect  if we are being sourced, and, if so, return with error.
# ===============================================================
[[ "${BASH_SOURCE[0]}" != "$0" ]] && {
    echo >&2 "This script should not be sourced."
    return 1
}

# ===============================================================
# Go
# ===============================================================
main "$@"
